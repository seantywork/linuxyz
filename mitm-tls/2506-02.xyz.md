#

```shell
sudo ip netns exec net2 openssl s_server -port 9999  -cert ./certs/server.pem -key ./certs/server_priv.pem -cipher AES256-SHA256:@SECLEVEL=0 -tls1_2

```


```shell

sudo ip netns exec net1 openssl s_client -connect 192.168.64.6:9999 -CAfile ./certs/ca.pem -cipher AES256-SHA256:@SECLEVEL=0 -tls1_2
```

#

```shell
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : AES256-SHA256
```

#

```shell
# https://datatracker.ietf.org/doc/html/rfc5246

...
  To generate the key material, compute

      key_block = PRF(SecurityParameters.master_secret,
                      "key expansion",
                      SecurityParameters.server_random +
                      SecurityParameters.client_random);

   until enough output has been generated.  Then, the key_block is
   partitioned as follows:

      client_write_MAC_key[SecurityParameters.mac_key_length]
      server_write_MAC_key[SecurityParameters.mac_key_length]
      client_write_key[SecurityParameters.enc_key_length]
      server_write_key[SecurityParameters.enc_key_length]
      client_write_IV[SecurityParameters.fixed_iv_length]
      server_write_IV[SecurityParameters.fixed_iv_length]

...


```


```c
/*
 *  steal start
 *  https://github.com/openssl/openssl/blob/master/providers/implementations/kdfs/tls1_prf.c
 *
*/
static int tls1_prf_P_hash(EVP_MAC_CTX *ctx_init,
                           const unsigned char *sec, size_t sec_len,
                           const unsigned char *seed, size_t seed_len,
                           unsigned char *out, size_t olen)
{
    size_t chunk;
    EVP_MAC_CTX *ctx = NULL, *ctx_Ai = NULL;
    unsigned char Ai[EVP_MAX_MD_SIZE];
    size_t Ai_len;
    int ret = 0;

    if (!EVP_MAC_init(ctx_init, sec, sec_len, NULL))
        goto err;
    chunk = EVP_MAC_CTX_get_mac_size(ctx_init);
    if (chunk == 0)
        goto err;
    /* A(0) = seed */
    ctx_Ai = EVP_MAC_CTX_dup(ctx_init);
    if (ctx_Ai == NULL)
        goto err;
    if (seed != NULL && !EVP_MAC_update(ctx_Ai, seed, seed_len))
        goto err;

    for (;;) {
        /* calc: A(i) = HMAC_<hash>(secret, A(i-1)) */
        if (!EVP_MAC_final(ctx_Ai, Ai, &Ai_len, sizeof(Ai)))
            goto err;
        EVP_MAC_CTX_free(ctx_Ai);
        ctx_Ai = NULL;

        /* calc next chunk: HMAC_<hash>(secret, A(i) + seed) */
        ctx = EVP_MAC_CTX_dup(ctx_init);
        if (ctx == NULL)
            goto err;
        if (!EVP_MAC_update(ctx, Ai, Ai_len))
            goto err;
        /* save state for calculating next A(i) value */
        if (olen > chunk) {
            ctx_Ai = EVP_MAC_CTX_dup(ctx);
            if (ctx_Ai == NULL)
                goto err;
        }
        if (seed != NULL && !EVP_MAC_update(ctx, seed, seed_len))
            goto err;
        if (olen <= chunk) {
            /* last chunk - use Ai as temp bounce buffer */
            if (!EVP_MAC_final(ctx, Ai, &Ai_len, sizeof(Ai)))
                goto err;
            memcpy(out, Ai, olen);
            break;
        }
        if (!EVP_MAC_final(ctx, out, NULL, olen))
            goto err;
        EVP_MAC_CTX_free(ctx);
        ctx = NULL;
        out += chunk;
        olen -= chunk;
    }
    ret = 1;

 err:
    EVP_MAC_CTX_free(ctx);
    EVP_MAC_CTX_free(ctx_Ai);
    OPENSSL_cleanse(Ai, sizeof(Ai));
    return ret;
}
/*
 * steal end
*/
```

#

```shell

seclen: 48, seedlen: 54, olen: 48
sec:
0303C50E21125FEC8635A168DA82BD7269D18B1AD4D5BEA6818527F55F4C2872AD6E4EBACA83BAC3B36E69E4ED15916F
seedstr: extended master secretW�SPeK^"�勘�0�U�n^��/��@&r�
seed:
657874656E646564206D61737465722073656372657457E5535065064B1F5E2286E58B981EE730E055C96E5EBA0FFA2FB3D0402672D7
out:
4D35748B193F886FB3193298D08159AE1E94CF77887A2083D6AA164D4E78D734772906F96F336BE5518AF5B6F450EC5A
seclen: 48, seedlen: 77, olen: 160
sec:
4D35748B193F886FB3193298D08159AE1E94CF77887A2083D6AA164D4E78D734772906F96F336BE5518AF5B6F450EC5A
seedstr: key expansion���n_     'B��C񚌠e&Oqb�
}Oɉ�_H�
seed:
6B657920657870616E73696F6EB519C2E76E5F09274282CC43F19A8CA065264F716216D20A7D4FC98907FD5F48840800745893FFE3F025D356EBA71346456907FAB463E830A91CFF28EACF6268
out:
ABAD28DAB7B616EB03B55B58E516B9B6A30FBF6283BE3372179C036F5A662D6CA86CAB7F0C17F5AA6C3FFAB275CA475834F024E6143E1B5AED0A58C720A35E9C7E8EC02569BFCCEECF6E7C5E6DA04008BD98803D346317D9D283C2B7BAB56CED237D9845D9C2B963A9D03FC8A39042A5398E9F15D280B8536485DB2093F5296FF5134EAE36A5B49C096A7C6D210A30EDBA2E61D143B965E6B4664C1E3F821EBD
seclen: 48, seedlen: 47, olen: 12
sec:
4D35748B193F886FB3193298D08159AE1E94CF77887A2083D6AA164D4E78D734772906F96F336BE5518AF5B6F450EC5A
seedstr: client finishedW�SPeK^"�勘�0�U�n^��/��@&r�
seed:
636C69656E742066696E697368656457E5535065064B1F5E2286E58B981EE730E055C96E5EBA0FFA2FB3D0402672D7
out:
B16679F75903CDDED98F1410
seclen: 48, seedlen: 47, olen: 12
sec:
4D35748B193F886FB3193298D08159AE1E94CF77887A2083D6AA164D4E78D734772906F96F336BE5518AF5B6F450EC5A
seedstr: server finished}g��+[��˶�
seed:
7365727665722066696E69736865647D67F8AA2B5B1799B3CBB6E3A700F587A8920B80D7E1848346DF829D5ADD4FE1
out:
9EFC18B4D2A28F38DC3818B6

```

#
```shell
# https://datatracker.ietf.org/doc/html/rfc7627
...
The "session_hash" is intended to encompass all relevant session
   information, including ciphersuite negotiation, key exchange
   messages, and client and server identities.  The hash is needed to
   compute the extended master secret and hence must be available before
   the Finished messages.

   This document sets the "session_hash" to cover all handshake messages
   up to and including the ClientKeyExchange.
...
```

#

```shell
# https://datatracker.ietf.org/doc/html/rfc7366
...
3.  Applying Encrypt-then-MAC

   Once the use of encrypt-then-MAC has been negotiated, processing of
   TLS/DTLS packets switches from the standard:

   encrypt( data || MAC || pad )

   to the new:

   encrypt( data || pad ) || MAC

   with the MAC covering the entire packet up to the start of the MAC
   value.  In TLS [2] notation, the MAC calculation for TLS 1.0 without
   the explicit Initialization Vector (IV) is:

   MAC(MAC_write_key, seq_num +
       TLSCipherText.type +
       TLSCipherText.version +
       TLSCipherText.length +
       ENC(content + padding + padding_length));
...
   and for TLS 1.1 and greater with an explicit IV is:

   MAC(MAC_write_key, seq_num +
       TLSCipherText.type +
       TLSCipherText.version +
       TLSCipherText.length +
       IV +
       ENC(content + padding + padding_length));
...

```